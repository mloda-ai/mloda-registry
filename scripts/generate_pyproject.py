#!/usr/bin/env python3
"""Generate pyproject.toml files from shared configuration.

Usage:
    python scripts/generate_pyproject.py          # Generate all files
    python scripts/generate_pyproject.py --check  # Check if files are up-to-date
"""
from __future__ import annotations

import argparse
import sys
from pathlib import Path

if sys.version_info >= (3, 11):
    import tomllib
else:
    import tomli as tomllib  # type: ignore[import-not-found]

CONFIG_DIR = Path("config")
SHARED_CONFIG = CONFIG_DIR / "shared.toml"
PACKAGES_CONFIG = CONFIG_DIR / "packages.toml"

HEADER = """\
# AUTO-GENERATED by scripts/generate_pyproject.py
# Do not edit directly - modify config/shared.toml or config/packages.toml instead
"""


def to_toml_list(items: list) -> str:
    """Format a list as TOML with double quotes."""
    quoted = [f'"{item}"' for item in items]
    return f"[{', '.join(quoted)}]"


def load_configs() -> tuple[dict, dict]:
    """Load shared and packages configuration."""
    with open(SHARED_CONFIG, "rb") as f:
        shared = tomllib.load(f)
    with open(PACKAGES_CONFIG, "rb") as f:
        packages = tomllib.load(f)
    return shared, packages


def generate_pyproject(pkg_name: str, pkg_config: dict, shared: dict) -> str:
    """Generate pyproject.toml content for a package."""
    lines = [HEADER]

    # Build system
    lines.append("[build-system]")
    lines.append(f'requires = {to_toml_list(shared["build-system"]["requires"])}')
    lines.append(f'build-backend = "{shared["build-system"]["build-backend"]}"')
    lines.append("")

    # Project section
    lines.append("[project]")
    lines.append(f'name = "{pkg_name}"')
    lines.append(f'version = "{shared["project"]["version"]}"')
    lines.append(f'description = "{pkg_config["description"]}"')

    if pkg_config.get("has_readme"):
        lines.append('readme = "README.md"')

    lines.append(f'license = "{pkg_config["license"]}"')

    # Authors - format as inline table
    authors = shared["project"]["authors"]
    author_strs = [f'{{ name = "{a["name"]}", email = "{a["email"]}" }}' for a in authors]
    lines.append(f'authors = [{", ".join(author_strs)}]')

    # Dependencies
    deps = pkg_config.get("dependencies", [])
    lines.append(f"dependencies = {to_toml_list(deps)}")

    lines.append(f'requires-python = "{shared["project"]["requires-python"]}"')
    lines.append("")

    # Optional dependencies
    if "optional_dependencies" in pkg_config:
        lines.append("[project.optional-dependencies]")
        for group, deps in pkg_config["optional_dependencies"].items():
            lines.append(f"{group} = {to_toml_list(deps)}")
        lines.append("")

    # URLs
    lines.append("[project.urls]")
    for key, value in shared["project"]["urls"].items():
        lines.append(f'{key} = "{value}"')
    lines.append("")

    # Setuptools config
    if pkg_config.get("is_meta_package"):
        lines.append("[tool.setuptools]")
        lines.append("packages = []")
    elif "include" in pkg_config:
        # Calculate relative path from package dir to repo root
        pkg_path = Path(pkg_config["path"])
        depth = len(pkg_path.parts)
        rel_path = "/".join([".."] * depth)

        lines.append("[tool.setuptools.packages.find]")
        lines.append(f'where = ["{rel_path}"]')
        lines.append(f'include = {to_toml_list(pkg_config["include"])}')
        lines.append("namespaces = true")
    lines.append("")

    # UV sources for workspace deps
    if "workspace_deps" in pkg_config:
        lines.append("[tool.uv.sources]")
        for dep in pkg_config["workspace_deps"]:
            lines.append(f'{dep} = {{ workspace = true }}')
        lines.append("")

    return "\n".join(lines)


def get_pyproject_path(pkg_config: dict) -> Path:
    """Get the pyproject.toml path for a package."""
    return Path(pkg_config["path"]) / "pyproject.toml"


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate pyproject.toml files")
    parser.add_argument("--check", action="store_true", help="Check if files are up-to-date")
    args = parser.parse_args()

    shared, packages_config = load_configs()
    packages = packages_config.get("packages", {})

    errors = []
    updated = []

    for pkg_name, pkg_config in packages.items():
        pyproject_path = get_pyproject_path(pkg_config)
        expected_content = generate_pyproject(pkg_name, pkg_config, shared)

        if args.check:
            if pyproject_path.exists():
                current_content = pyproject_path.read_text()
                if current_content != expected_content:
                    errors.append(f"{pyproject_path}: out of date")
            else:
                errors.append(f"{pyproject_path}: missing")
        else:
            # Ensure parent directory exists
            pyproject_path.parent.mkdir(parents=True, exist_ok=True)
            pyproject_path.write_text(expected_content)
            updated.append(str(pyproject_path))
            print(f"  ✓ {pyproject_path}")

    if args.check:
        if errors:
            print("❌ Files out of date:")
            for e in errors:
                print(f"  - {e}")
            print("\nRun 'python scripts/generate_pyproject.py' to regenerate")
            return 1
        print(f"✅ All {len(packages)} pyproject.toml files are up-to-date")
        return 0

    print(f"\n✅ Generated {len(updated)} pyproject.toml files")
    return 0


if __name__ == "__main__":
    sys.exit(main())
